{"name":"Id","tagline":"Simple, immutable models based on hashes","body":"# id\r\n### simple, immutable models based on hashes\r\n\r\nJSON is a great way to transfer data between systems, and it's easy to parse into a Ruby hash. But sometimes it's nice to have actual methods to call when you want to get attributes from your data, rather than coupling your entire codebase to the hash representation by littering it with calls to `fetch` or `[]`. The same goes for BSON documents stored in Mongo.\r\n\r\nThat's where `id` (as in Freud) comes in. You define your model classes using syntax that should look pretty familiar if you've used any popular Ruby ORMs - but `id` is not an ORM. Model objects defined with `id` have a constructor that accepts a hash, and you define the values of this hash that are made readable as fields, but that hash can come from any source.\r\n\r\n#### Defining a model\r\n\r\nTo define a model, include the `Id::Model` module in your class.\r\n\r\n```ruby\r\nclass Cat\r\n  include Id::Model\r\nend\r\n```\r\n\r\n#### Defining fields\r\n\r\nAt its most basic, you can define a field like this:\r\n\r\n```ruby\r\nclass Cat\r\n  field :name\r\nend\r\n```\r\n\r\nThis gives you the equivalent of an `attr_reader` for that field, as well as a predicate method which checks if it has been set (in the case of boolean fields, this predicate method also checks the value of that field - nil is interpreted as false).\r\n\r\n```ruby\r\ncat = Cat.new(name: \"Travis\")\r\ncat.name  # => \"Travis\"\r\ncat.name? # => true\r\n\r\ncat = Cat.new\r\ncat.name? # => false\r\n```\r\n\r\n###### What happens if you try to access a field that hasn't been set?\r\n\r\n```ruby\r\nirb(main):007:0> Cat.new.name\r\n  Id::MissingAttributeError: Cat had a nil value for 'name'.\r\n```\r\nId is allergic to `nil`, and refuses to return it. If you want to access a field you need to be sure it's there, or you'll get an error. This means if you have a bug in your code and a field isn't set, you'll find out as soon as possible, rather that letting a `nil` leak out and cause an `undefined method 'foo' for nil:NilClass` at some unspecified future point, from where it might be hard to track down the source of the problem.\r\n\r\n###### What about optional fields?\r\n\r\nSometimes fields really are optional. In this case you can either test for their presence using the predicate methods (which is a bit ugly, but at least forces you to deal with the empty case), or you can mark the field as `optional: true`, which will make them return an `Option` type rather than a raw value.\r\n\r\n`Option` types are a pattern found in many functional languages (the `Option` type in Scala, the `Maybe` monad in Haskell) and the Ruby implementation used by id can be found [here](http://github.com/rsslldnphy/optional).\r\n\r\n###### Can I set default values?\r\n\r\nYes. Default values are specified like this:\r\n\r\n```ruby\r\nclass Cat\r\n  ...\r\n  field :paws, default: 4\r\nend\r\n\r\nCat.new.paws # => 4\r\n```\r\n\r\nYou can also specify lambda defaults. These will be run on initialization of an instance of your model.\r\n\r\n```ruby\r\nclass Cat\r\n  ...\r\n  field :birthday, default: -> { Date.new }\r\nend\r\n\r\nCat.new.birthday # => #<Date: 2013-10-21 ((2456587j,0s,0n),+0s,2299161j)>\r\n```\r\n\r\n###### I don't like the key names in my data-source :-(\r\n\r\nWe don't always get what we want. But don't despair! If the hash you're using to create your models has badly named keys - e.g., horror of horrors, keys in camelCase - you can use key aliases to convert them to nice, succinct, Rubyish identifiers:\r\n\r\n```ruby\r\nclass Camel\r\n  include Id::Model\r\n\r\n  field :name,  key: 'camelName'\r\n  field :humps, key: 'camelHumps'\r\nend\r\n\r\nCamel.new('camelName' => 'Terry').name # => \"Terry\"\r\n```\r\n\r\n#### Type Coercion\r\n\r\nId can coerce your fields into a number of basic types. Just specify the type you want as part of the field definition.\r\n\r\n```ruby\r\nclass Cat\r\n  ...\r\n  field :paws, type: Integer\r\nend\r\n\r\nCat.new(paws: \"3\").paws => 3\r\nCat.new(paws: \"3\").paws.class => Integer\r\n```\r\n\r\nYou can typecast array elements like this:\r\n\r\n```ruby\r\nfield :counts, type: Array[Integer]\r\n```\r\n\r\nBecause Ruby doesn't have a `Boolean` type (weird, right?), if you want to coerce something to either `true` or `false`, you need to use `Id::Boolean`, like this:\r\n\r\n```ruby\r\nfield :admin, type: Id::Boolean\r\n```\r\n\r\nAnd if you need to coerce a type id doesn't yet support, such as a custom type of your own, you can register new coercions by passing the \"from\" type, \"to\" type, and a block to perform the conversion to `Id::Coercion.register`.\r\n\r\n```ruby\r\nId::Coercion.register String, Money do |value|\r\n  value.to_money\r\nend\r\n```\r\nor more succinctly:\r\n\r\n```ruby\r\nId::Coercion.register String, Money, &:to_money\r\n```\r\n\r\n#### Associations\r\n\r\nIf you have nested arrays or hashes in your source, you can define id models for them in turn, and treat them much like you would associations in an ORM, by defining them as `has_one` or `has_many` associations on the parent model.\r\n\r\n```ruby\r\nclass Lion\r\n  include Id::Model\r\n  field :name\r\nend\r\n\r\nclass Person\r\n  include Id::Model\r\n  field :name\r\nend\r\n\r\nclass Zoo\r\n  include Id::Model\r\n\r\n  has_many :lions\r\n  has_one :zookeeper, type: Person\r\nend\r\n\r\nzoo = Zoo.new(lions: [{name: 'Hetty'}],\r\n              zookeeper: {name: 'Russell'})\r\n\r\nzoo.lions.first.class # => Lion\r\nzoo.lions.first.name  # => \"Hetty\"\r\nzoo.zookeeper.class   # => Person\r\nzoo.zookeeper.name    # => \"Russell\"\r\n```\r\n\r\nTypes are inferred from the association name unless specified.\r\n\r\n#### Designed for immutability\r\n\r\n`id` models provide accessor methods, but no mutator methods, because they are designed for immutability. How do immutable models work? When you need to change some field of a model object, a new copy of the object is created with the field changed as required. This is handled for you by `id`'s `set` method:\r\n\r\n```ruby\r\nperson1 = Person.new(name: 'Russell', job: 'programmer')\r\nperson2 = person1.set(name: 'Radek')\r\nperson1.name # => 'Russell'\r\nperson2.name # => 'Radek'\r\nperson2.job  # => 'programmer'\r\n```\r\n\r\nObviously, this is Ruby, and if you really want to mutate some of the internal state of an id model you will be able to find a way to do it. Don't do it!\r\n\r\n#### Id and Rails\r\n\r\nWe might not love everything about Rails, but we probably use it at least some of the time. So does id play nicely with it?\r\n\r\nWith a few modifications, yes. Models that blow up at the sight of `nil` don't play happy with Rails' `nil`-happy forms, but you can make your id models active model compliant in forms, while otherwise retaining the `nil`-allergy in the rest of your code, by doing two things.\r\n\r\nInclude the `Id::Form` module in your model.\r\n\r\n```ruby\r\nclass Cat\r\n  include Id::Model\r\n  include Id::Form\r\nend\r\n```\r\n\r\nAdd the following line to `config/application.rb`:\r\n\r\n```ruby\r\nconfig.action_view.default_form_builder = Id::FormBuilder\r\n```\r\n\r\n### Timestamps\r\n\r\nAnd finally, it's reasonably common to want to know when a particular model was created and/or updated. Id provides you this functionality out of the box through the `Id::Timestamps` module. Just include it to your model to get `created_at` and `updated_at` fields that behave as you would expect.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}